create table if not EXISTS "public"."instruments" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "name" character varying
);


alter table "public"."instruments" enable row level security;

create table "public"."invitations" (
    "id" bigint generated by default as identity not null,
    "email" character varying,
    "token" character varying,
    "created_at" timestamp with time zone not null default now(),
    "expired_at" character varying
);


alter table "public"."invitations" enable row level security;

create table "public"."roles" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "name" character varying
);


alter table "public"."roles" enable row level security;

create table "public"."user_instrument" (
    "id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default now(),
    "instrument_id" bigint,
    "user_id" uuid
);


alter table "public"."user_instrument" enable row level security;

create table "public"."users" (
    "id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default now(),
    "first_name" character varying,
    "last_name" character varying,
    "address" jsonb,
    "phone_number" character varying,
    "phone_number_2" character varying,
    "auth_id" uuid,
    "avatar_url" character varying,
    "role_id" bigint
);


alter table "public"."users" enable row level security;

CREATE UNIQUE INDEX instrument_user_pkey ON public.user_instrument USING btree (id);

CREATE UNIQUE INDEX instruments_pkey ON public.instruments USING btree (id);

CREATE UNIQUE INDEX invitations_pkey ON public.invitations USING btree (id);

CREATE UNIQUE INDEX roles_pkey ON public.roles USING btree (id);

CREATE UNIQUE INDEX user_pkey ON public.users USING btree (id);

alter table "public"."instruments" add constraint "instruments_pkey" PRIMARY KEY using index "instruments_pkey";

alter table "public"."invitations" add constraint "invitations_pkey" PRIMARY KEY using index "invitations_pkey";

alter table "public"."roles" add constraint "roles_pkey" PRIMARY KEY using index "roles_pkey";

alter table "public"."user_instrument" add constraint "instrument_user_pkey" PRIMARY KEY using index "instrument_user_pkey";

alter table "public"."users" add constraint "user_pkey" PRIMARY KEY using index "user_pkey";

alter table "public"."user_instrument" add constraint "user_instrument_instrument_id_fkey" FOREIGN KEY (instrument_id) REFERENCES instruments(id) not valid;

alter table "public"."user_instrument" validate constraint "user_instrument_instrument_id_fkey";

alter table "public"."user_instrument" add constraint "user_instrument_user_id_fkey" FOREIGN KEY (user_id) REFERENCES users(id) not valid;

alter table "public"."user_instrument" validate constraint "user_instrument_user_id_fkey";

alter table "public"."users" add constraint "users_auth_id_fkey" FOREIGN KEY (auth_id) REFERENCES auth.users(id) not valid;

alter table "public"."users" validate constraint "users_auth_id_fkey";

alter table "public"."users" add constraint "users_role_id_fkey" FOREIGN KEY (role_id) REFERENCES roles(id) not valid;

alter table "public"."users" validate constraint "users_role_id_fkey";

create policy "Enable read access for all users"
on "public"."instruments"
as permissive
for all
to public
using (true);


create policy "Enable read access for all users"
on "public"."invitations"
as permissive
for select
to public
using (true);


create policy "Enable read access for all users"
on "public"."roles"
as permissive
for select
to public
using (true);


create policy "Enable read access for all users"
on "public"."user_instrument"
as permissive
for all
to public
using (true);


create policy "Enable read access for all users"
on "public"."users"
as permissive
for all
to public
using (true);



